"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTimer = void 0;
var react_1 = require("react");
var reducer_1 = __importDefault(require("./state/reducer"));
exports.useTimer = function (_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.autostart, autostart = _c === void 0 ? false : _c, endTime = _b.endTime, _d = _b.initialTime, initialTime = _d === void 0 ? 0 : _d, _e = _b.interval, interval = _e === void 0 ? 1000 : _e, onTimeOver = _b.onTimeOver, onTimeUpdate = _b.onTimeUpdate, _f = _b.step, step = _f === void 0 ? 1 : _f, _g = _b.timerType, timerType = _g === void 0 ? 'INCREMENTAL' : _g;
    var _h = react_1.useReducer(reducer_1.default, {
        status: 'STOPPED',
        time: initialTime,
        timerType: timerType,
    }), state = _h[0], dispatch = _h[1];
    var status = state.status, time = state.time;
    var advanceTime = react_1.useCallback(function (timeToAdd) {
        dispatch({ type: 'advanceTime', payload: { timeToAdd: timeToAdd } });
    }, []);
    var pause = react_1.useCallback(function () {
        dispatch({ type: 'pause' });
    }, []);
    var reset = react_1.useCallback(function () {
        dispatch({ type: 'reset', payload: { initialTime: initialTime } });
    }, [initialTime]);
    var start = react_1.useCallback(function () {
        dispatch({ type: 'start', payload: { initialTime: initialTime } });
    }, []);
    react_1.useEffect(function () {
        if (autostart) {
            dispatch({ type: 'start', payload: { initialTime: initialTime } });
        }
    }, [autostart]);
    react_1.useEffect(function () {
        if (typeof onTimeUpdate === 'function') {
            onTimeUpdate(time);
        }
    }, [time]);
    react_1.useEffect(function () {
        if (status !== 'STOPPED' && time === endTime) {
            dispatch({ type: 'stop' });
            if (typeof onTimeOver === 'function') {
                onTimeOver();
            }
        }
    }, [endTime, onTimeOver, time, status]);
    react_1.useEffect(function () {
        var intervalId = null;
        if (status === 'RUNNING') {
            intervalId = setInterval(function () {
                dispatch({
                    type: 'set',
                    payload: {
                        newTime: timerType === 'DECREMENTAL' ? time - step : time + step,
                    },
                });
            }, interval);
        }
        else if (intervalId) {
            clearInterval(intervalId);
        }
        return function () {
            if (intervalId) {
                clearInterval(intervalId);
            }
        };
    }, [status, step, timerType, interval, time]);
    return { advanceTime: advanceTime, pause: pause, reset: reset, start: start, status: status, time: time };
};
